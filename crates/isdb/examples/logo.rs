use std::fs::File;
use std::io::BufReader;
use std::path::PathBuf;

use fxhash::{FxHashMap, FxHashSet};
use isdb::data_module::LogoType;

#[derive(Debug)]
struct AppArgs {
    raw: bool,
    output: PathBuf,
    input: PathBuf,
}

impl AppArgs {
    const HELP: &str = "\
ロゴを抽出するコマンド

USAGE:
  logo [OPTIONS] [INPUT]

FLAGS:
  -h, --help     このヘルプを表示する

OPTIONS:
  --raw          抽出したロゴデータを生で出力する
  --output PATH  ロゴを出力する先のディレクトリ

ARGS:
  <INPUT>
";

    pub fn parse() -> Result<AppArgs, Box<dyn std::error::Error>> {
        let mut args = pico_args::Arguments::from_env();

        if args.contains(["-h", "--help"]) {
            println!("{}", Self::HELP);
            std::process::exit(0);
        }

        let raw = args.contains("--raw");
        let output = args
            .opt_value_from_str("--output")?
            .unwrap_or_else(PathBuf::new);

        Ok(AppArgs {
            raw,
            output,
            input: args.free_from_str()?,
        })
    }
}

// 参考
// - https://github.com/Chinachu/node-aribts/blob/4617d4b7bd34abfcb042fecf2fface29fcd50f7b/src/logo_clut.ts
// - https://github.com/Chinachu/node-aribts/blob/4617d4b7bd34abfcb042fecf2fface29fcd50f7b/src/logo.ts
const PLTE: [u8; 399] = [
    0x00, 0x00, 0x01, 0x83, 0x50, 0x4C, 0x54, 0x45, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
    0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA,
    0x00, 0xAA, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x55, 0x00, 0x55, 0x00, 0x00, 0x55,
    0x55, 0x00, 0x55, 0xAA, 0x00, 0x55, 0xFF, 0x00, 0xAA, 0x55, 0x00, 0xAA, 0xFF, 0x00, 0xFF, 0x55,
    0x00, 0xFF, 0xAA, 0x55, 0x00, 0x00, 0x55, 0x00, 0x55, 0x55, 0x00, 0xAA, 0x55, 0x00, 0xFF, 0x55,
    0x55, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0xAA, 0x55, 0x55, 0xFF, 0x55, 0xAA, 0x00, 0x55, 0xAA,
    0x55, 0x55, 0xAA, 0xAA, 0x55, 0xAA, 0xFF, 0x55, 0xFF, 0x00, 0x55, 0xFF, 0x55, 0x55, 0xFF, 0xAA,
    0x55, 0xFF, 0xFF, 0xAA, 0x00, 0x55, 0xAA, 0x00, 0xFF, 0xAA, 0x55, 0x00, 0xAA, 0x55, 0x55, 0xAA,
    0x55, 0xAA, 0xAA, 0x55, 0xFF, 0xAA, 0xAA, 0x55, 0xAA, 0xAA, 0xFF, 0xAA, 0xFF, 0x00, 0xAA, 0xFF,
    0x55, 0xAA, 0xFF, 0xAA, 0xAA, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0xFF, 0x00, 0xFF, 0xFF, 0x55, 0x00,
    0xFF, 0x55, 0x55, 0xFF, 0x55, 0xAA, 0xFF, 0x55, 0xFF, 0xFF, 0xAA, 0x00, 0xFF, 0xAA, 0x55, 0xFF,
    0xAA, 0xAA, 0xFF, 0xAA, 0xFF, 0xFF, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
    0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA,
    0x00, 0xAA, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00, 0x00, 0x55, 0x00, 0x55, 0x00, 0x00, 0x55,
    0x55, 0x00, 0x55, 0xAA, 0x00, 0x55, 0xFF, 0x00, 0xAA, 0x55, 0x00, 0xAA, 0xFF, 0x00, 0xFF, 0x55,
    0x00, 0xFF, 0xAA, 0x55, 0x00, 0x00, 0x55, 0x00, 0x55, 0x55, 0x00, 0xAA, 0x55, 0x00, 0xFF, 0x55,
    0x55, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0xAA, 0x55, 0x55, 0xFF, 0x55, 0xAA, 0x00, 0x55, 0xAA,
    0x55, 0x55, 0xAA, 0xAA, 0x55, 0xAA, 0xFF, 0x55, 0xFF, 0x00, 0x55, 0xFF, 0x55, 0x55, 0xFF, 0xAA,
    0x55, 0xFF, 0xFF, 0xAA, 0x00, 0x55, 0xAA, 0x00, 0xFF, 0xAA, 0x55, 0x00, 0xAA, 0x55, 0x55, 0xAA,
    0x55, 0xAA, 0xAA, 0x55, 0xFF, 0xAA, 0xAA, 0x55, 0xAA, 0xAA, 0xFF, 0xAA, 0xFF, 0x00, 0xAA, 0xFF,
    0x55, 0xAA, 0xFF, 0xAA, 0xAA, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0xFF, 0x00, 0xFF, 0xFF, 0x55, 0x00,
    0xFF, 0x55, 0x55, 0xFF, 0x55, 0xAA, 0xFF, 0x55, 0xFF, 0xFF, 0xAA, 0x00, 0xFF, 0xAA, 0x55, 0xFF,
    0xAA, 0xAA, 0xFF, 0xAA, 0xFF, 0xFF, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0x06, 0xDD, 0x27, 0x7B,
];
const TRNS: [u8; 141] = [
    0x00, 0x00, 0x00, 0x81, 0x74, 0x52, 0x4E, 0x53, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7B, 0x70, 0xF7, 0x6F,
];

fn save_logo(
    args: &AppArgs,
    saved_logos: &mut FxHashMap<(u16, u16, u16, LogoType), FxHashSet<Vec<u8>>>,
    saved_count: &mut usize,
    logo: &isdb::filters::logo::LogoData,
) {
    // 透明なロゴは除外
    if logo.data.len() <= 93 {
        return;
    }

    let logos = saved_logos
        .entry((
            logo.network_id,
            logo.logo_id,
            logo.logo_version,
            logo.logo_type,
        ))
        .or_default();
    if !logos.insert(logo.data.to_vec()) {
        // 既に同じデータが保存済み
        return;
    }

    let data: std::borrow::Cow<[u8]> = if args.raw {
        logo.data.into()
    } else {
        if !logo.data.starts_with(b"\x89PNG\r\n\x1a\n") {
            eprintln!("不正なPNG形式");
            return;
        }

        [&logo.data[..33], &PLTE, &TRNS, &logo.data[33..]]
            .concat()
            .into()
    };

    let mut name = format!(
        "{:04X}_{:03X}_{:03X}_{:02X}",
        logo.network_id, logo.logo_id, logo.logo_version, logo.logo_type.0,
    );
    if logos.len() > 1 {
        name += &*format!("-{}", logos.len());
    }
    name += ".png";
    let path = args.output.join(&*name);

    match std::fs::write(&*path, &*data) {
        Ok(()) => {
            println!("'{}'へロゴを保存", path.display());
            *saved_count += 1;
        }
        Err(e) => eprintln!("'{}'へのロゴの保存に失敗：{}", path.display(), e),
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = AppArgs::parse()?;
    env_logger::init();

    let f = File::open(&*args.input)?;
    let f = BufReader::with_capacity(188 * 1024, f);

    let mut saved_logos = FxHashMap::default();
    let mut saved_count = 0;

    let mut demuxer =
        isdb::demux::Demuxer::new(isdb::filters::logo::LogoDownloadFilter::new(|logo| {
            save_logo(&args, &mut saved_logos, &mut saved_count, logo)
        }));

    for packet in isdb::Packet::iter(f) {
        let packet = packet?;
        demuxer.feed(&packet);
    }

    if saved_count == 0 {
        return Err("ロゴが見つかりませんでした".into());
    }

    println!("{}個のロゴを保存", saved_count);
    Ok(())
}
